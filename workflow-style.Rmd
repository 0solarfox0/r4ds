# Workflow: code style {#workflow-style}

```{r, results = "asis", echo = FALSE}
status("polishing")
```

Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.
Even as a very new programmer it's a good idea to work on your code style.
Use a consistent style makes it easier for others (including future-you!) to read your work, and is particularly important if you need to get help from someone else.
This chapter will introduce to the most important points of the [tidyverse style guide](https://style.tidyverse.org), which is used throughout this book.

Styling your code will feel a bit tedious to start with, but if you practice it, it will soon become second nature.
Additionally, there are some great tools to quickly restyle existing code, like the [styler](http://styler.r-lib.org) package by Lorenz Walthert.
Once you've installed it with `install.packages("styler")`, an easy way to use it is via RStudio's **command palette**.
The command palette lets you use any build-in RStudio command, as well as many addins provided by packages.
Open the palette by pressing Cmd/Ctrl + Shift + P, then type "styler" to see all the shortcuts provided by styler.
Figure \@ref(fig:styler) shows the results.

```{r styler}
#| echo: false
#| out.width: NULL
#| fig.cap: > 
#|   RStudio's command palette makes it easy to access every RStudio command
#|   using only the keyboard.
#| fig.alt: >
#|   A screenshot showing the command palette after typing "styler", showing
#|   the four styling tool provided by the package.
knitr::include_graphics("screenshots/rstudio-palette.png")
```

```{r setup}
library(tidyverse)
library(nycflights13)
```

## Names

Variable names (those created by `<-` and those created by `mutate()`) should use only lowercase letters, numbers, and `_`.
Use underscores (`_`) to separate words within a name.

```{r, eval = FALSE}
# Strive for:
short_flights <- flights |> filter(air_time < 60)

# Avoid:

```

As a general rule of thumb, it's better to prefer long, descriptive names that are easy to understand, rather than concise names that are fast to type.
Short names save relatively little time when writing code (especially since autocomplete will help you finish typing them), but can be expensive when you come back to old need and need to puzzle out what a cryptic abbreviation means.

Strive for consistency with your names.

Prefixes are generally better than suffixes because of autocomplete.

## Spaces

Put spaces on either side of mathematical operators apart from `^` (e.g `+`, `-`, `==`, `<`), and around the assignment operator (`<-`).
Don't put spaces inside or outside parentheses for regular function calls.
Always put a space after a comma, just like in regular English.

```{r, eval = FALSE}
# Strive for
(a + b)^2 / d
mean(x, na.rm = TRUE)

# Avoid
( a + b ) ^ 2/d
mean (x ,na.rm=TRUE)
```

It's OK to add extra spaces if it improves alignment.
For example, if you're creating multiple variables in `mutate()`, you might want to add spaces so that all the `=` line up.
This is particularly useful in `case_when()` as it makes it easier to skim the conditions and the values.

```{r, eval = FALSE}
flights |> 
  mutate(
    speed      = air_time / distance,
    dep_hour   = dep_time %/% 100,
    dep_minute = dep_time %%  100
  )
```

## Pipes

`|>` should always have a space before it and should always be followed by a new line or space (usually a new line).
After the first step, each line should be indented by two spaces.

If the function has named arguments (like `mutate()` or `summarise()`) then put each argument on a new line, indented by another two spaces.
Make sure the closing parentheses start a new line and are lined up with the start of the function name.

```{r, eval = FALSE}
# Strive for 
flights |>  
  filter(!is.na(arr_delay), !is.na(tailnum)) |> 
  group_by(tailnum) |> 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

# Avoid
flights|> filter(!is.na(arr_delay), !is.na(tailnum)) |> 
  group_by(tailnum) |> summarise(delay = mean(arr_delay, na.rm = TRUE), 
                                 n = n())
```

This structure makes it easier to add new steps (or rearrange existing steps), modify elements within a step, and to get a 50,000 view just by skimming the left-hand side.

It's OK to shirk some of these rules if your snippet fits easily on one line.
But in our experience, it's pretty common for short snippets to grow longer, so you'll usually save time in the long run by starting with all the vertical space you need.

```{r, eval = FALSE}
# This fits compactly on one line
df |> mutate(y = x + 1)

# While this spacing feels breezy, it's easily extended to 
# more variables and more steps
df |> 
  mutate(
    y = x + 1
  )
```

The same basic rules apply to ggplot2, just treat `+` the same way as `|>`.

```{r, eval = FALSE}
flights |> 
  group_by(month) |> 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE)
  ) |> 
  ggplot(aes(month, delay)) +
  geom_point() + 
  geom_line()
```

If you can fit all of the arguments on to a single line, put each argument on its own line.

```{r, eval = FALSE}
flights |> 
  group_by(dest) |> 
  summarise(
    distance = mean(distance),
    speed = mean(air_time / distance, na.rm = TRUE)
  ) |> 
  ggplot(aes(distance, speed)) +
  geom_smooth(
    method = "loess",
    span = 0.5,
    se = FALSE, 
    colour = "white", 
    size = 4
  ) +
  geom_point()
```

Be wary of writing very long pipes, say longer than 10-15 lines.
Try to break them up into smaller sub-tasks, giving each task an informative name.
The names will help cue the reader into what's happening and makes it easier to check that intermediate results are as expected.
Whenever you can give something an informative name, you should give it an informative name.
Don't expect to get it right the first time!
This means breaking up long pipelines if there are intermediate states that can get good names.

## Organisation

Use comments to explain the "why" of your code, not the "how" or the "what".
If you simply describe what your code is doing in prose, you'll have to be careful to update the comment and code in tandem: if you change the code and forget to update the comment, they'll be inconsistent which will lead to confusion when you come back to your code in the future.
For data analysis code, use comments to explain your overall plan of attack and record important insight as you encounter them.
There's way to re-capture this knowledge from the code itself.

As your scripts get longer, use **sectioning** comments to break up your file into manageable pieces:

```{r, eval = FALSE}
# Load data --------------------------------------

# Plot data --------------------------------------
```

RStudio provides a keyboard shortcut to create these headers (Cmd/Ctrl + Shift + R), and will display them in the code navigation drop-down at the bottom-left of the editor, as shown in Figure \@ref(fig:rstudio-sections).

```{r rstudio-sections, echo = FALSE, out.width = NULL}
#| echo: false
#| out.width: NULL
#| fig.cap: > 
#|   After adding sectioning comments to your script, you can
#|   easily navigate to them using the code navigation tool in the
#|   bottom-left of the script editor.
knitr::include_graphics("screenshots/rstudio-nav.png")
```
